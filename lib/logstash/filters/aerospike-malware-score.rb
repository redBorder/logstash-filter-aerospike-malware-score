# encoding: utf-8
require "logstash/filters/base"
require "logstash/namespace"

require "yaml"
require 'aerospike'

class LogStash::Filters::AerospikeMalwareScore < LogStash::Filters::Base

  include Aerospike

  config_name "aerospike-malware-score"

  # Hash field.
  config :hash_field,                       :validate => :string,           :default => 'sha256'
  # Malware weights scores file.
  config :malware_weights_file,             :validate => :string,           :default => "/opt/rb/var/rb-sequence-oozie/conf/weights.yml"
  # Aerospike configuration file.
  config :aerospike_config_file,            :validate => :string,           :default => "/opt/rb/var/www/rb-rails/config/aerospike.yml"
  # Aerospike server in the form "host:port".
  config :aerospike_server,                 :validate => :string,           :default => ""
  # Namespace is a Database name in Aerospike.
  config :namespace,                        :validate => :string,           :default => "malware"
  # Set in Aerospike is similar to table in a relational database.
  # Where are scores stored.
  config :set_hash_scores,                  :validate => :string,           :default => "hashScores"
  # Where are control files stored.
  config :set_control_files,                :validate => :string,           :default => "controlFiles"
  # Loader name.
  config :loader_score_name,                :validate => :string,           :required => true
  # Loader type.
  config :loader_type,                      :validate => :string,           :default => "fb"
  # Time to live values in Aerospike.
  config :ttl,                              :validate => :number,           :default => 0
  # Aerospike bin name where data location is going to be stored.
  config :s3_bin_name,                      :validate => :string,           :default => "s3_uuids"


  public
  def register
    # Add instance variables
    @aerospike_server = servers if @aerospike_server.empty?
    @aerospike_server = @aerospike_server.first if @aerospike_server.class.to_s == "Array"
    
    register_aerospike

  end # def register

  private

  # Create aerospike from the first aerospike server found in aerospike config file
  # or from "localhost:3000"
  def register_aerospike
    begin
      host,port = @aerospike_server.first.split(":")
      @aerospike = Client.new(Host.new(host, port))
    rescue Aerospike::Exceptions::Aerospike => ex
      @aerospike = nil
      @logger.error(ex.message)
    end
  end
  
  # Get servers from Aerospike configuration file
  #
  # @return [String] Aerospike servers
  def servers
    servers = []
    if File.exist?(@aerospike_config_file)
      production_config = YAML.load_file(@aerospike_config_file)
      servers = production_config["production"]["servers"] || []
    end
    servers = "localhost:3000" if servers.empty?
    servers
  end

  # Update malware hash scores in Aerospike.
  #
  # This method set the score for the given loader and update the scores where
  # the loader belongs and the global one.
  #
  # There are three kinds of scores:
  #
  # 1. Loader score: score given by each of the loaders.
  # E.g. 'virustotal', 'clamscan'...
  #
  # 2. Section score: there are three kinds of sections where the loaders
  # belongs to:
  # * Realtime
  # * Fast batch
  # * Slow batch
  #
  # 3. Global score
  def update_malware_hash_score

    @logger.info("Updating malware score for #{@hash}.")
    # Set loader score
    @logger.info("Storing #{@loader_score_name} in Aerospike.")
    set_record(Bin.new(@loader_score_name, @loader_score), @set_hash_scores)

    record = get_record(@set_hash_scores)
    section_score_name = "g_" + @loader_type + "_score"
    global_score_name = "score"

    list_type = get_list_type(record)

    global_score = 0.0
    section_score = 0.0
    bins = []

    unless record.nil?
      scores = record.bins

      # Compute section score.
      @logger.info("Computing section score")
      scores.each do | entry_key, entry_value |
        if entry_key.start_with? @loader_type and !entry_key.include? "score"
          local_score = entry_value.to_f
          weight = YAML.load_file(@malware_weights_file)["hash"][entry_key]

          if local_score > 0
            section_score += local_score * weight
          end
        end
        @logger.info("Storing section score in Aerospike")
        bins.push(Bin.new(section_score_name, section_score.round))
      end

      # Compute global score.
      @logger.info("Computing global score")
      case list_type
      when "black"
        @logger.info("Hash " + @hash + " is blacklisted")
        global_score = 100
      when "white"
        @logger.info("Hash " + @hash + " is whitelisted")
        global_score = 0

      else
        scores.each do | entry_key, entry_value |
          if entry_key.start_with? "g_"
            local_score = entry_value.to_f
            weight = YAML.load_file(@malware_weights_file)["hash"][entry_key]

            if local_score > 0
              global_score += local_score * weight
            end
          end
        end
      end
    end
    bins.push(Bin.new(global_score_name, global_score.round))
    @logger.info("Storing global score in Aerospike")
    set_record(bins, @set_hash_scores)
  end

  # Get list type from Aerospike record.
  #
  # List type is whether a record is blacklisted, whitelisted or none.
  #
  # @param record [Aerospike::Record, nil] Aerospike record
  # @return [String] List type or nil if list type is not defined.
  def get_list_type(record)
    record.bins["list_type"] unless record.nil?
  end

  # Get Aerospike record where key is @hash.
  #
  # A record with the Aerospike database consists of one or more record "bins" (name-value pairs) and meta-data,
  # including time-to-live and generation; a record is uniquely identified by it's key within a given namespace.
  #
  # @return [record,nil] Aerospike record or nil if record does not exist.
  def get_record(set)
    key = Key.new(@namespace, set, @hash) rescue nil
    @aerospike.get(key,[], Policy.new) rescue nil
  end

  # Set Aerospike record for given bin and set.
  #
  # A record is the basic unit of storage in the database.
  # Records can belong to a namespace or to a set within the namespace.
  # A single record is uniquely identified by a key. The record data is stored in bins.
  # Bins consist of a name and a value. This value can be also an array.
  #
  # @param bin [Aerospike::bin] Aerospike bin
  # @param set [Aerospike::bin] Aerospike set
  def set_record(bin, set)
    begin
      key = Key.new(@namespace, set, @hash)

      policy = WritePolicy.new
      policy.expiration = @ttl

      @aerospike.put(key,bin,policy)
    rescue Aerospike::Exceptions::Aerospike => ex
      @logger.error(ex.message)
    end
  end

  # Update Aerospike record to control where is located the hash analysis results.
  #
  # This is used to make queries over these results using e.g. Apache Drill.
  def update_data_location

    bin = nil

    record = get_record(@set_control_files)

    if record.nil?
      bin = Bin.new(@s3_bin_name, ["rt"])
    else
      locations = record.bins[@s3_bin_name]

      bin = Bin.new(@s3_bin_name, ["rt"]) if locations.nil?

      unless locations.nil?
        if locations.empty?
          bin = Bin.new(@s3_bin_name, ["rt"])
        elsif !locations.include? 'rt'
          locations.push('rt')
          bin = Bin.new(@s3_bin_name,locations)
        end
      end
    end

    unless bin.nil?
      @logger.info("Storing data s3 location in set #{@set_control_files}")
      set_record(bin,@set_control_files)
    end
  end

  public
  def filter(event)

    # Solve the problem that happen when:
    # at time of registering the plugin the
    # aerospike was not there
    register_aerospike if @aerospike.nil?
     

    @hash = event.get(@hash_field)
    @loader_score = event.get(@loader_score_name)

    update_malware_hash_score

    update_data_location

    # filter_matched should go in the last line of our successful code
    filter_matched(event)

  end  # def filter(event)
end # class LogStash::Filters::AerospikeMalwareScore
